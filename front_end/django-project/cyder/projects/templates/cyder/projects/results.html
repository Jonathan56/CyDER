{% extends 'cyder/base.html' %}
{% load static %}

{% block css %}
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.2.0/dist/leaflet.css"
        integrity="sha512-M2wvCLH6DSRazYeZRIm1JnYyh22purTM+FDB5CsyxtQJYeKq83arPe5wgbNmcFXGqiSH2XR8dT/fJISVA1r/zQ=="
        crossorigin=""/>
    <style>/* Style for LeafletMap componenet */
        .leaflet-popup-content {
            /* Override the fact that leaflet.js set the width in the style attribute of the popup
            to enforce the min and max width option in leaflet.
            This default behavior can be a problem when vuejs rewrite a popup (the size is calculated for the old content).
            If a max size is needed for a popup it should be enforce inside the popup itself
            (ex: put the content inside a div with a set width and use this div for the popup) */
            width: auto !important;
        }
        .info {
            padding: 6px 8px;
            font: 14px/16px Arial, Helvetica, sans-serif;
            background: white;
            background: rgba(255,255,255,0.8);
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            border-radius: 5px;
        }
        .info h4 {
            margin: 0 0 5px;
            color: #777;
        }

        .legend {
            line-height: 18px;
            color: #555;
        }
        .legend i {
            width: 75px;
            height: 25px;
            float: left;
            margin-right: 8px;
            opacity: 0.7;
        }
    </style>
{% endblock css %}

{% block content %}
<!--     <div id="project-results"></div> -->

    <div id="app" v-if="project !== null">
        <h1>Results</h1>
        <leaflet-map style="height: 70vh; margin: 0.1rem 0 1rem 0;">
            <results-layer-a  v-if="SelectedPhase=='A'" v-if="loaded" :geojson="geo" fit></results-layer-a>
            <results-layer-b  v-if="SelectedPhase=='B'" v-if="loaded" :geojson="geo" fit></results-layer-b>
            <results-layer-c  v-if="SelectedPhase=='C'" v-if="loaded" :geojson="geo" :properties="mouseOnProp" fit></results-layer-c>
<!--             <controller  v-if="loaded" :geojson="geo"></controller> -->
            <legend-layer  v-if="loaded" ></legend-layer>
        </leaflet-map>
        <div class="btn-group btn-group-sm" role="group" style="display: flex; margin-bottom: 1em;">
            <button type="button" class="btn btn-secondary"  @click="SelectedPhase='A'" style="width: 33.3%;">Phase A</button>
            <button type="button" class="btn btn-secondary"  @click="SelectedPhase='B'" style="width: 33.3%;">Phase B</button>
            <button type="button" class="btn btn-secondary"  @click="SelectedPhase='C'" style="width: 33.3%;">Phase C</button>
        </div>
        <div v-if="loaded" class="slidecontainer">
          <input type="range" min="0" max="1000" value="1" class="slider" v-model="sliderValue" style="width: 100%;">
        </div>
    </div>

{% endblock content %}

{% block script %}



    <script src="https://unpkg.com/leaflet@1.2.0/dist/leaflet.js"
        integrity="sha512-lInM/apFSqyy1o6s89K4iQUKg6ppXEgsVxT35HbzUupEVRh2Eu9Wdl4tHj7dZO0s1uvplcYGmt3498TtHq+log=="
        crossorigin=""></script>

    <script type="module">
        import { LeafletMap } from '{% static 'cyder/models/viewer.js' %}';
        import { ModelLayer } from '{% static 'cyder/models/layers.js' %}';
        import { ResultsLayerA, ResultsLayerB,  ResultsLayerC, Controller, LegendLayer} from '{% static 'cyder/projects/results.js' %}';
        import CyderAPI from '{% static 'cyder/api.js' %}';
        import notifyRESTError from '{% static 'cyder/api-notify-error.js' %}';

        document.querySelector(".navbar [data-name='projects']").classList.add('active');

        window.onload = function() {
            CyderAPI.auth();


            // DEBUG: Keep a reference to the Vuejs app in window.app to make it available easily in the console for debug
            window.app = new Vue({
                el: '#app',
                components: { LeafletMap, ModelLayer, ResultsLayerA, ResultsLayerB,  ResultsLayerC, Controller, LegendLayer},
                data: {
                    project: null,
                    layer: '',
                    results: null,
                    datetimes: null,
                    geo: null,
                    lines: null,
                    points: null,
                    indexValue: 0, //this variable is used for development and is bound to change as we introduce the time variable from timestamps
                    loaded: false,
                    SelectedPhase: null,
                    sliderValue: null,
                    mouseOnProp: null,
                },
                methods: {
                    async loadProject(id) {
                        //loads project from pg db
                        //loads and parses results from pg db
                        //collects geojson model data
                        try {
                            this.project = await CyderAPI.Project.get(id, true);
                            this.results=[]
                            let r= this.project.results;
                            for (var i = 0; i < r.length-1; i++) {
                                this.results.push(JSON.parse(r[i]));
                            }
                            this.datetimes=(r[r.length-1])
                            this.geo = await CyderAPI.rest('GET', `/api/models/${encodeURI(this.project.settings.model)}/geojson/`);
                            this.loadFeatures();
                            this.getPointFeatureResult();
                            this.getLineFeatureResult();
                            //this.test();
                            this.loaded=true;
                        } catch(error) {
                            if(!(error instanceof CyderAPI.RESTError))
                                throw(error);
                            notifyRESTError(error);
                        }
                    },

                    loadFeatures(){
                        this.lines=[];
                        this.points=[];
                        if (this.geo!=null){
                            for (let i=0; i<this.geo.features.length;i++){
                                if (this.geo.features[i].geometry.type=="LineString"){
                                    this.lines.push(this.geo.features[i]);
                                } else if (this.geo.features[i].geometry.type=="Point"){
                                    this.points.push(this.geo.features[i]);
                                }
                            }
                        }
                    },


                    getPointFeatureResult(){
                        //adds result properties and corresponding values to geojson point features 
                        //apparently section_ids do not correspond accross results and imported model, we will thus be using to_node and from_node to identify a line's results
                        for (let i=0; i<Object.keys(this.results[this.indexValue].node_id).length; i++){
                            for (let j=0; j<this.points.length; j++){
                                if(this.points[j].properties.id===this.results[this.indexValue].node_id[i]){
                                    this.points[j].properties.vA=this.results[this.indexValue].voltage_A[i];
                                    this.points[j].properties.vB=this.results[this.indexValue].voltage_B[i];
                                    this.points[j].properties.vC=this.results[this.indexValue].voltage_C[i];   
                                }
                            }
                        }

                    },

                    getLineFeatureResult(){
                        //adds result properties and corresponding values to geojson line features
                        for (let i=0; i<this.lines.length; i++){
                            let xA=null,xB=null,xC=null,yA=null,yB=null,yC=null;
                            for (let j=0; j<this.points.length; j++){
                                if(this.points[j].properties.id===this.lines[i].properties.from_node){
                                    xA=this.points[j].properties.vA;
                                    xB=this.points[j].properties.vB;
                                    xC=this.points[j].properties.vC;
                                } else if (this.points[j].properties.id===this.lines[i].properties.to_node){
                                    yA=this.points[j].properties.vA;
                                    yB=this.points[j].properties.vB;
                                    yC=this.points[j].properties.vC;
                                }
                            }
                            if (xA!=null && yA!=null) {this.lines[i].properties.vA=(xA+yA)/2;} else {this.lines[i].properties.vA=null}
                            if (xB!=null && yB!=null) {this.lines[i].properties.vB=(xB+yB)/2;} else {this.lines[i].properties.vB=null}
                            if (xC!=null && yC!=null) {this.lines[i].properties.vC=(xC+yC)/2;} else {this.lines[i].properties.vC=null}
                        }
                    },

                    getDatetimesIndex(x){
                        this.indexTest= Math.round(this.datetimes.length*(x/100));
                    },

                    test(){
                        let info = L.control();
                        info.onAdd = function (map) {
                            this._div = L.DomUtil.create('div', 'info'); // create a div with a class "info"
                            this.update();
                            return this._div;
                        };
                        info.update = function (props) {
                            this._div.innerHTML = '<h4>US Population Density</h4>';
                        };
                        alert(this.Layer.map);
                    },
                },
            });
            app.loadProject("{{ project_id|escapejs }}");
        };

    </script>

{% endblock script %}
